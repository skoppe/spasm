// File is autogenerated with `dub spasm:webidl -- --bindgen`
import {spasm as spa, encoders as encoder, decoders as decoder} from '../modules/spasm.js';
let spasm = spa;
const setBool = (ptr, val) => (spasm.heapi32u[ptr/4] = +val),
      setInt = (ptr, val) => (spasm.heapi32s[ptr/4] = val),
      setUInt = (ptr, val) => (spasm.heapi32u[ptr/4] = val),
      setShort = (ptr, val) => (spasm.heapi16s[ptr/2] = val),
      setUShort = (ptr, val) => (spasm.heapi16u[ptr/2] = val),
      setByte = (ptr, val) => (spasm.heapi8s[ptr] = val),
      setUByte = (ptr, val) => (spasm.heapi8u[ptr] = val),
      setFloat = (ptr, val) => (spasm.heapf32[ptr/4] = val),
      setDouble = (ptr, val) => (spasm.heapf64[ptr/8] = val),
      getBool = (ptr) => spasm.heapi32u[ptr/4],
      getInt = (ptr) => spasm.heapi32s[ptr/4],
      getUInt = (ptr) => spasm.heapi32u[ptr/4],
      getShort = (ptr) => spasm.heapi16s[ptr/2],
      getUShort = (ptr) => spasm.heapi16u[ptr/2],
      getByte = (ptr) => spasm.heapi8s[ptr],
      getUByte = (ptr) => spasm.heapi8u[ptr],
      getFloat = (ptr) => spasm.heapf32[ptr/4],
      getDouble = (ptr) => spasm.heapf64[ptr/8],
      isDefined = (val) => (val != undefined && val != null),
      encode_handle = (ptr, val) => { setUInt(ptr, spasm.addObject(val)); },
      decode_handle = (ptr) => { return spasm.objects[getUInt(ptr)]; },
      spasm_encode_string = encoder.string,
      spasm_decode_string = decoder.string,
      spasm_indirect_function_get = (ptr)=>spasm.instance.exports.__indirect_function_table.get(ptr);
const spasm_encode_Handle = encode_handle,
  spasm_encode_optional_Handle = (ptr, val)=>{
    if (setBool(ptr+4, isDefined(val))) {
      spasm_encode_Handle(ptr, val);
    }
  };
export let jsExports = {
  MouseEvent_clientX_Get: (ctx) => {
    return spasm.objects[ctx].clientX;
  },
  Document_createElement_0: (ctx, localNameLen, localNamePtr) => {
    return spasm.addObject(spasm.objects[ctx].createElement(spasm_decode_string(localNameLen, localNamePtr)));
  },
  Element_innerHTML_Set: (ctx, innerHTMLLen, innerHTMLPtr) => {
    spasm.objects[ctx].innerHTML = spasm_decode_string(innerHTMLLen, innerHTMLPtr);
  },
  EventTarget_addEventListener_0: (ctx, typeLen, typePtr, callbackCtx, callbackPtr) => {
    spasm.objects[ctx].addEventListener(spasm_decode_string(typeLen, typePtr), (event)=>{encode_handle(0, event);spasm_indirect_function_get(callbackPtr)(callbackCtx, 0)});
  },
  Node_appendChild: (ctx, node) => {
    return spasm.addObject(spasm.objects[ctx].appendChild(spasm.objects[node]));
  },
  ParentNode_querySelector: (rawResult, ctx, selectorsLen, selectorsPtr) => {
    spasm_encode_optional_Handle(rawResult, spasm.objects[ctx].querySelector(spasm_decode_string(selectorsLen, selectorsPtr)));
  },
  CSSStyleDeclaration_setter__string_string: (ctx, propertyLen, propertyPtr, valueLen, valuePtr) => {
    spasm.objects[ctx][spasm_decode_string(propertyLen, propertyPtr)] = spasm_decode_string(valueLen, valuePtr);
  },
  ElementCSSInlineStyle_style_Get: (ctx) => {
    return spasm.addObject(spasm.objects[ctx].style);
  },
  console_log: (data) => {
    console.log(spasm.objects[data]);
  },
}